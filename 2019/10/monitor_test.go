package monitor

import (
	"fmt"
	"reflect"
	"testing"
)

var puzzleInput = `.#..#..##.#...###.#............#.
.....#..........##..#..#####.#..#
#....#...#..#.......#...........#
.#....#....#....#.#...#.#.#.#....
..#..#.....#.......###.#.#.##....
...#.##.###..#....#........#..#.#
..#.##..#.#.#...##..........#...#
..#..#.......................#..#
...#..#.#...##.#...#.#..#.#......
......#......#.....#.............
.###..#.#..#...#..#.#.......##..#
.#...#.................###......#
#.#.......#..####.#..##.###.....#
.#.#..#.#...##.#.#..#..##.#.#.#..
##...#....#...#....##....#.#....#
......#..#......#.#.....##..#.#..
##.###.....#.#.###.#..#..#..###..
#...........#.#..#..#..#....#....
..........#.#.#..#.###...#.....#.
...#.###........##..#..##........
.###.....#.#.###...##.........#..
#.#...##.....#.#.........#..#.###
..##..##........#........#......#
..####......#...#..........#.#...
......##...##.#........#...##.##.
.#..###...#.......#........#....#
...##...#..#...#..#..#.#.#...#...
....#......#.#............##.....
#......####...#.....#...#......#.
...#............#...#..#.#.#..#.#
.#...#....###.####....#.#........
#.#...##...#.##...#....#.#..##.#.
.#....#.###..#..##.#.##...#.#..##`

func TestInput(t *testing.T) {
	tcs := []struct {
		input string
		scan  Map
	}{
		{
			input: ".#..#\n.....\n#####\n....#\n...##",
			scan: Map{
				Range: XY{5, 5},
				Grid: grid{
					XY{1, 0}: true,
					XY{4, 0}: true,
					XY{0, 2}: true,
					XY{1, 2}: true,
					XY{2, 2}: true,
					XY{3, 2}: true,
					XY{4, 2}: true,
					XY{4, 3}: true,
					XY{3, 4}: true,
					XY{4, 4}: true,
				},
			},
		},
	}

	for _, tc := range tcs {
		got := Scan(tc.input)
		if reflect.DeepEqual(got, tc.scan) == false {
			t.Errorf("maps not equal\n%s\n\n%s", got, tc.scan)
		}
	}
}

func TestLocate(t *testing.T) {
	tcs := []struct {
		input    string
		location XY
		visible  int
	}{
		{
			input:    ".#..#\n.....\n#####\n....#\n...##",
			location: XY{3, 4},
			visible:  8,
		},
		{
			input:    "......#.#.\n#..#.#....\n..#######.\n.#.#.###..\n.#..#.....\n..#....#.#\n#..#....#.\n.##.#..###\n##...#..#.\n.#....####",
			location: XY{5, 8},
			visible:  33,
		},
		{
			input:    "#.#...#.#.\n.###....#.\n.#....#...\n##.#.#.#.#\n....#.#.#.\n.##..###.#\n..#...##..\n..##....##\n......#...\n.####.###.",
			location: XY{1, 2},
			visible:  35,
		},
		{
			input:    ".#..#..###\n####.###.#\n....###.#.\n..###.##.#\n##.##.#.#.\n....###..#\n..#.#..#.#\n#..#.#.###\n.##...##.#\n.....#.#..",
			location: XY{6, 3},
			visible:  41,
		},
		{
			input:    ".#..##.###...#######\n##.############..##.\n.#.######.########.#\n.###.#######.####.#.\n#####.##.#.##.###.##\n..#####..#.#########\n####################\n#.####....###.#.#.##\n##.#################\n#####.##.###..####..\n..######..##.#######\n####.##.####...##..#\n.#####..#.######.###\n##...#.##########...\n#.##########.#######\n.####.#.###.###.#.##\n....##.##.###..#####\n.#.#.###########.###\n#.#.#.#####.####.###\n###.##.####.##.#..##",
			location: XY{11, 13},
			visible:  210,
		},
	}
	for _, tc := range tcs {
		m := Scan(tc.input)
		l, v := Locate(m)
		if l != tc.location {
			t.Errorf("%v != %v", l, tc.location)
		}
		if v != tc.visible {
			t.Errorf("%v != %v", v, tc.visible)
		}
	}
}

func TestPartOne(t *testing.T) {
	m := Scan(puzzleInput)
	_, v := Locate(m)
	fmt.Println("Part One:", v)
}

func TestVaporiseN(t *testing.T) {
	tcs := []struct {
		input    string
		location XY
		n        int
		want     int
	}{
		{
			input:    ".#....#####...#..\n##...##.#####..##\n##...#...#.#####.\n..#.....X...###..\n..#.#.....#....##",
			location: XY{8, 3},
			n:        9,
			want:     1501,
		},
		{
			input:    ".#..##.###...#######\n##.############..##.\n.#.######.########.#\n.###.#######.####.#.\n#####.##.#.##.###.##\n..#####..#.#########\n####################\n#.####....###.#.#.##\n##.#################\n#####.##.###..####..\n..######..##.#######\n####.##.####...##..#\n.#####..#.######.###\n##...#.##########...\n#.##########.#######\n.####.#.###.###.#.##\n....##.##.###..#####\n.#.#.###########.###\n#.#.#.#####.####.###\n###.##.####.##.#..##",
			location: XY{11, 13},
			n:        200,
			want:     802,
		},
	}
	for _, tc := range tcs {
		m := Scan(tc.input)
		pn := VaporiseN(m, tc.location, tc.n)
		got := 100*pn.x + pn.y
		if got != tc.want {
			t.Errorf("%v: %d != %d", pn, got, tc.want)
		}
	}
}

func TestPartTwo(t *testing.T) {
	n := 200
	m := Scan(puzzleInput)
	l, _ := Locate(m)
	pn := VaporiseN(m, l, n)
	got := 100*pn.x + pn.y
	fmt.Println("Part Two:", got)
}
